f = open("_out.210616020519197ioM6dDGuywEUzqenB9g43lsflarge.aln", "r")
#Открываме файл с данными, полученными после выравнивания в mafft
ll = [] # Начало части 1: Создем список списков, в каждый элемент которого мы запишем по строке из файла, и каждый из днаных элементов будет состоять из двух подэлементов - Информации об организме, из которго взята последовательность и сама последовательность 
test = [] #
for line in f:
    sl = line.strip() #Удаление "вайтспейс" символов - например, символа конца строки
    lil = sl.split() #Делим строку на два вышеуказанных подэлемента
    if lil != test:
      lil.pop(0) #Если строка не пустая, то уничтожаем первый из данных подэлементов - нас интересуют только сами последовательности
    if lil == ['------------------------------------------------------------']:
      lil.pop(0) #Если строка полностью состоит из тире - уничтожаем ее сразу, нам нужно, чтобы в строке были нуклеотиды
    ll.append(lil) # Записываем полученное в список списков
#Начало части 2: Для удобства делаем из списка списков обыкновенный список, ведь каждый из элементов теперь состоит из всего лишь одного подэлемента.
flatLL = [] #Тот самый обыкновенный список
for elem in ll: #Аналогично первой части, запускаем цикл ащк, где проходимся по каждому из элементов массива
    flatLL.extend(elem) #Добавляем элемент из списка списков в список
#Начало части 3:Избавляемся от повторяющихся последовательностей
#Начало части 3.1:
temp = [[i, j] for i,j in enumerate(flatLL)] #Собираем пары, состоящие из данных элементов и индекса
temp = sorted(temp,key=lambda i: i[1]) #Сортируем их по значению элемента
#Начало части 3.2:
i = 0
result32 = [] #Пустой массив-плейсхолдер для результата в данной части
while i < len(temp): #Начинаем цикл while с ограничением в длину ранее указанного массива
    j = 0 #Задаем переменную. Она будет использоваться для поиска совпадений
    while i + 1 + j < len(temp) and temp[i][1] == temp[i+j+1][1]: #С помощью цикла находим повторения. Если значение элемента повторится, то о станет равно 1, но если повторений не будет, то о так и останется равным 0
        j += 1
    if j == 0: #Повторы не найдены? Значит, элемент можно добавлять в новый список вместе с его старым индексом
        result32.append(temp[i])
    i = i + j + 1
#Начало части 3.3:
k = sorted(result32,key=lambda i: i[0]) #Сортируем обратно, теперь по индексам, сохраненным ранее
result33 = [i[1] for i  in k] #Записываем оставшиеся элементы в список
#Начало части 4: Избавляемся от слишком коротких или слишком длинных последовательностей и также последовательности, содержащие символы, обозночающие более одного нуклеотида одновременно
suslist = []
def susornot():
    if sus == 1: #Если последовательность подозрительна*, то
        suslist.append(string) #записываем ее в список подозрительных*
resultFIN = [] #Создаем список, в который в итоге будут записаны необходимые нам последовательности
eleswitch = 0 # Вводим переменную, которая будет действовать в качестве переключателя, как о в 3.2 - при появлении символов, обозначающих конкретные нуклеотиды, переключатель будет иметь значение 1, при попадании на символ тире - значение 0
for elem in result33: #Начинаем проходить по списку с результатами части 3 поэлементно.
    string = elem #Записываем значение элемента в переменную
    sus = 0 #Создаем маркер для обозначения *подозрительных последовательностей - в них встречаются сторонние символы
    count = 0 #Создаем счетчик идущих подряд нуклеотидов
    count2 = 0 #Создаем счетчик обработанных элементов в строке
    for ele in string: #Проходим по каждому символу в строке, используя цикл ащк
        count2 += 1 #Увеличиваем значение счетчика обработанных символов
        if ele not in ('a', 'c', 't', 'g', 'u', '-'):
            sus = 1 #Попался сторонний символ, последовательность подозрительна
        if ele == ('a' or 'c' or 't' or 'g' or 'u'): #
            eleswitch = 1 #"Включаем" переключатель, так как встретили нуклеотид
        elif ele == '-':
            eleswitch = 0 #"Выключаем" переключатель, так как встретили пропуск вместо нуклеотида
        if eleswitch == 1:
            count += 1 #Наткнулись на нуклеотид, поэтому увеличиваем значение счетчика подряд идущих нуклеотидов на 1
            if count >= 25 and count <= 45 and count2 == 60: #Если есть последовательность длиной между 25 и 45, и обработаны все символы, то
                resultFIN.append(string) #данная последовательность записывается в ответ
                susornot() #Данная последовательность была определена подозрительной? Если да, то нужно записать ее в список подозрительных
                break
        elif eleswitch == 0: #Если мы наткнулись на символ тире, то
            if count >= 25 and count <= 45: #Если длина следующих друг за другом нуклеотидов, предшествовавших этому тире, была между 25 и 45, то
                resultFIN.append(string) #данная последовательность записывается в ответ
                susornot() #Данная последовательность была определена подозрительной? Если да, то нужно записать ее в список подозрительных
                break #и произволится выход из цикла
            count = 0 #Нет? счетчик обнуляется.
        if count2 == 60: #Если подходящей последовательности в итоге не найдено, то
            break #выходим из цикла
f.close() #Закрываем файл
a = input("Нажмите Ввод, чтобы увидеть результаты")
print("Here are the final results:", resultFIN) #Все последовательности, прошедшие по критериям
print("Here are the suspicious ones:", suslist) #Все подозрительные последовательности
print("The amount of final seq-ses:", len(resultFIN)) #Количество прошедших последовательностей
print("The amount of suspicious seq-ses:", len(suslist)) #Количество подозрительных последовательностей
